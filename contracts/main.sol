// SPDX-License-Identifier: GPL-3.0
import "./Ownable.sol";
import "./FarmerRole.sol";
import "./DistributorRole.sol";
import "./RetailerRole.sol";
import "./Roles.sol";
import "./Context.sol";

pragma solidity >= 0.5.0 < 0.9.0;

contract main is
    Ownable,
    FarmerRole,
    DistributorRole,
    RetailerRole
{
  struct Transbyfarmer{
    uint256 id;
    uint256 productCode;
    string productName;
    string distName;
    string quantity;
    string timestamp;
    uint256 price;
}
    mapping(uint256 => Transbyfarmer) transbyfarmer;
    mapping(uint256 => Transbydistributor) transbydistributor;

struct Transbydistributor{
    uint256 id;
    string productName;
    string retailName;
    uint256 batches;
    string timestamp;
    uint256 price;
}

    struct Transbyretailer{
        uint256 id;
        string productName;
        string CustomerName;
        uint256 batches;
        string timestamp;
        uint256 price;
}

    event FarmerTransaction(uint256 id,uint256 productCode,string productName,string distName,string quantity,string timestamp,uint256 price);
    event DistributorTransaction(uint256 id,string productName,string retailName,uint256 batches,string timestamp,uint256 price);
    address owner;
    // Define a variable called 'productCode' for Universal Product Code (productCode)
    uint256 productCode;
  
    mapping(uint256 => Item) items;
    

    enum Modified {
        CropRegistered,
        ForSaleByFarmer,
        PurchasedByDistributor,
        ShippedByFarmer, // 3
        ReceivedByDistributor, // 4
        ProcessedByDistributor, // 6
        ForSaleByDistributor, // 7
        PurchasedByRetailer, // 8
        ShippedByDistributor, // 9
        ReceivedByRetailer, // 10
        ForSaleByRetailer
    }

    Modified constant defaultState = Modified.CropRegistered;

    uint256 public noteCount = 0;
    uint256 public note1 = 0;
    uint256 public note2 = 0;
  
    struct Item {
        uint256 stockUnit; // Stock Keeping Unit (stockUnit)
        uint256 productCode; // Universal Product Code (productCode), generated by the Farmer, goes on the package, can be verified by the Consumer
        address ownerID; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address farmerID; // Metamask-Ethereum address of the Farmer // ADDED PAYABLE
        string farmName; // Farmer Name
        string productDescription; // product Description 
        uint256 productID; // Product ID potentially a combination of productCode + stockUnit
        string productType; // Product types
        string productName;
        uint256 productDate; // Product Date NOTE: MIGHT NEED TO CHANGE type
        uint256 productPrice; // Product Price
        Modified itemState; // Product State as represented in the enum above
        address distributorID; // Metamask-Ethereum address of the Distributor
        address retailerID; // Metamask-Ethereum address of the Retailer
        string distName;
        string retailName;

    }

    // Block number stuct
    // struct Txblocks {
    //     uint256 FTD; // blockfarmerToDistributor
    //     uint256 DTR; // blockDistributorToRetailer
    // }

    event CropRegistered(uint256 productCode); //1
    // event ForSaleByFarmer(uint256 productCode); //2
    // event PurchasedByDistributor(uint256 productCode); //3
    // event ShippedByFarmer(uint256 productCode); //4
    // event ReceivedByDistributor(uint256 productCode); //5
    // event ProcessedByDistributor(uint256 productCode); //6
    // event ForSaleByDistributor(uint256 productCode); //7
    // event PurchasedByRetailer(uint256 productCode); //8
    // event ShippedByDistributor(uint256 productCode); //9
    // event ReceivedByRetailer(uint256 productCode); //10
    // event ForSaleByRetailer(uint256 productCode); //11

    // Define a modifer that checks to see if _msgSender() == owner of the contract
    modifier only_Owner() {
        require(_msgSender() == owner);
        _;
    }

    // Define a modifer that verifies the Caller
    modifier verifyCaller(address _address) {
        require(_msgSender() == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint256 _price) {
        require(msg.value >= _price);
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint256 _productCode, address payable addressToFund) {
        uint256 _price = items[_productCode].productPrice;
        uint256 amountToReturn = msg.value - _price;
        addressToFund.transfer(amountToReturn);
        _;
    }


    //Item State Modifiers
    modifier producedByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.CropRegistered);
        _;
    }

    modifier forSaleByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.ForSaleByFarmer);
        _;
    }

    modifier purchasedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.PurchasedByDistributor);
        _;
    }

    modifier shippedByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.ShippedByFarmer);
        _;
    }

    modifier receivedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.ReceivedByDistributor);
        _;
    }

      modifier processByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.ProcessedByDistributor);
        _;
    }

    modifier forSaleByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.ForSaleByDistributor);
        _;
    }

    modifier shippedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.ShippedByDistributor);
        _;
    }

    modifier purchasedByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.PurchasedByRetailer);
        _;
    }

    modifier receivedByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.ReceivedByRetailer);
        _;
    }

    modifier forSaleByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == Modified.ForSaleByRetailer);
        _;
    }

    // constructor setup owner stockUnit productCode
    constructor() public payable {
        owner = _msgSender();
        // stockUnit = 1;
        productCode = 1;
    }

    // Define a function 'kill'
    function kill() public {
        if (_msgSender() == owner) {
            address payable ownerAddressPayable = _make_payable(owner);
            selfdestruct(ownerAddressPayable);
        }
    }

    // allows you to convert an address into a payable address
    function _make_payable(address x) internal pure returns (address payable) {
        return payable(address(uint160(x)));
    }


/*
 1st step in supplychain
 Allows farmer to create product
*/
    function cropRegisteredByFarmer(
        uint256 _productCode,
        string memory _productName,
        string memory _productType, 
        string memory _productDescription,
        string memory _productDate,
        string memory _farmName,
        uint256 _price)
        public onlyFarmer 
    {
        address distributorID; // Empty distributorID address
        address retailerID; // Empty retailerID address
       
        Item memory newProduce; // Create a new struct Item in memory
        // newProduce.stockUnit = stockUnit; // Stock Keeping Unit (stockUnit)
        newProduce.productCode = _productCode; // Universal Product Code (productCode), generated by the Farmer, goes on the package, can be verified by the Consumer
        newProduce.ownerID = _msgSender(); // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        newProduce.farmerID = _msgSender(); // Metamask-Ethereum address of the Farmer
        newProduce.farmName = _farmName; // Farmer Name
        newProduce.productDescription = _productDescription; // Product Decription Information
       
        // newProduce.productID = _productCode + stockUnit; // Product ID
        newProduce.productType = _productType; // Product Type
        newProduce.productPrice = _price; // Product Price
        newProduce.productDate = block.timestamp;
        
        newProduce.itemState = defaultState; // Product State as represented in the enum above
        newProduce.distributorID = distributorID; // Metamask-Ethereum address of the Distributor
        newProduce.retailerID = retailerID; // Metamask-Ethereum address of the Retailer
       
        items[_productCode] = newProduce; // Add newProduce to items struct by productCode
        uint256 placeholder; // Block number place holder
        // Txblocks memory txBlock; // create new txBlock struct
        // txBlock.FTD = placeholder; // assign placeholder values
        // txBlock.DTR = placeholder;
        
        // itemsHistory[_productCode] = txBlock; // add txBlock to itemsHistory mapping by productCode

        // Increment stockUnit
        // stockUnit = stockUnit + 1;

        // Emit the appropriate event
        emit CropRegistered(_productCode);
    }



function transactionByFarmer(uint256 _productCode, string memory _productName, string memory _distName, string memory _quantity,string memory _timestamp, uint256 _price) 
public  {
     transbyfarmer[noteCount] = Transbyfarmer(noteCount,_productCode,_productName,_distName,_quantity,_timestamp,_price);
        emit FarmerTransaction(noteCount, _productCode,_productName,_distName,_quantity,_timestamp,_price);
    noteCount++;
}
   function transactionByDistributer( string memory _productName, string memory _retailName, uint256 _batches,string memory _timestamp, uint256 _price) 
public  {
     transbydistributor[note1] = Transbydistributor(note1,_productName,_retailName,_batches,_timestamp,_price);
        emit DistributorTransaction(note1,  _productName, _retailName, _batches, _timestamp, _price);
    note1++;
}


    // Farmer public farmer;
    // Distributor public distributor;
    // Retailer public retailer;
    // Product public product;

    // enum State{
    //     allowed,
    //     not_allowed,
    //     wait
    // }

    // State public farmerState = State.allowed;
    // State public DistributorState = State.not_allowed;
    // State public RetailerState = State.not_allowed;

    // string public product_name;
    // string public product_type;
    // string public description;
    // string public dateofharvest;

// ---------------------------------------Farmer Section-----------------------------------//

    // function farmerDetails(
    //     uint _fid, 
    //     string memory _fname, 
    //     string memory _femail,
    //     string memory _flocation, 
    //     uint _fphone, 
    //     string memory _fpass
    //     ) public {
    //         farmer.f_id = _fid;
    //         farmer.f_name = _fname;
    //         farmer.f_email = _femail;
    //         farmer.f_location = _flocation;
    //         farmer.f_phone = _fphone;
    //         farmer.f_password = _fpass;
    // }


    // function cropRegistration(
    //     string memory productname,
    //     string memory producttype, 
    //     string memory descript,
    //     string memory doh
    //     ) public returns(
    //         string memory, 
    //         uint, 
    //         string memory,
    //         string memory, 
    //         string memory,
    //         string memory, 
    //         string memory
    //         ){

    //         string memory farmername = farmer.f_name;
    //         uint farmerphone = farmer.f_phone;   
    //         string memory farmerlocation = farmer.f_location;
            
    //         product_name = productname;
    //         product_type = producttype;
    //         description = descript; 
    //         dateofharvest = doh;
             
    //         return (farmername, farmerphone, dateofharvest, farmerlocation, product_name, product_type, description);        
    // }

    // function addFarmertoProduct() public returns(string memory){
    //     if(farmerState == State.allowed){
    //         product.productName = product_name;
    //         product.productType = product_type;
    //         product.desc = description;
    //         product.farmer = farmer.f_name;
    //         product.date_of_harvest = dateofharvest;
    //         return("Farmer Details are Updated Successfully!!!");
    //     }
    //     else{
    //         revert("Something went wrong in Farmer's state");
    //     }
    // }

    // function soldtoDistrubutor() public returns(string memory){
    //     if(farmerState == State.allowed){
    //         product.distributor = distributor.d_name;
    //         DistributorState = State.allowed;
    //         return("Farmer Sold product to Distributor Successfully!!!!"); 
    //     }
    //     else{
    //         revert("Transaction between farmer and distributor not happened");
    //     }
    // }


//-------------------------------Distributer Section------------------------//

    // function distributorDetails(
    //     uint did,
    //     string memory dname, 
    //     string memory demail, 
    //     string memory dlocation, 
    //     uint dphone, 
    //     string memory dpassword
    //     ) public{
    //         uint d_id = did;
    //         string memory d_name = dname;
    //         string memory d_email = demail;
    //         string memory d_location = dlocation;
    //         uint d_phone = dphone;
    //         string memory d_password = dpassword;

    //         distributor.d_id = d_id;
    //         distributor.d_name = d_name;
    //         distributor.d_email = d_email;
    //         distributor.d_location = d_location;
    //         distributor.d_phone = d_phone;
    //         distributor.d_password = d_password;

    // }

    // function distributorBatch(uint batchId) public returns(string memory){
    //     if(DistributorState == State.allowed && farmerState == State.allowed ){
    //         product.batch_id = batchId;
    //         DistributorState = State.wait;
    //         return("Batch Id is assigned to the product");    
    //     }
    //     else{
    //         revert("Not Assigned Batch ID");
    //     }
    // }

    // function selltoRetailer() public returns(string memory){
    //     if(DistributorState == State.wait && farmerState == State.allowed){
    //         product.retailer = retailer.r_name;
    //         RetailerState = State.allowed;
    //         return("Distributor sold product to retailer");
    //     }
    //     else{
    //         revert("Transaction between distributor and retailer not happened");
    //     }
    // }
    

//---------------------------------------------------retailerDetails--------------------------------------//

    // function retailerDetails(
    //     uint rid, 
    //     string memory rname, 
    //     string memory remail, 
    //     string memory rlocation, 
    //     uint rphone, 
    //     string memory rpassword
    //     ) public{
    //         uint r_id = rid;
    //         string memory r_name = rname;
    //         string memory r_email = remail;
    //         string memory r_location = rlocation;
    //         uint r_phone = rphone;
    //         string memory r_password = rpassword;

    //         retailer.r_id = r_id;
    //         retailer.r_name = r_name;
    //         retailer.r_email = r_email;
    //         retailer.r_location = r_location;
    //         retailer.r_phone = r_phone;
    //         retailer.r_password = r_password;

    // }

//-----------------------------------------------------Product-------------------------------------------------------//

    // function productResult() public view returns(
    //     uint, 
    //     string memory, 
    //     string memory, 
    //     string memory,
    //     string memory, 
    //     string memory, 
    //     string memory, 
    //     string memory
    //     ){  return(
    //         product.batch_id,
    //         product.productName,
    //         product.desc,
    //         product.productType,
    //         product.date_of_harvest,
    //         product.farmer,
    //         product.distributor,
    //         product.retailer
    //     );
    // }

//--------------------------------------------sample-----------------

    // address payable user = payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);
    

}